"""
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
 AUTOTECHNIK BOT ¬∑ main.py ¬∑ v4.5  (full version, modified)
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
"""

import asyncio
import json
import logging
import os
import re
import sqlite3
from collections import defaultdict, deque
from urllib.parse import quote_plus

import httpx
import nest_asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from telegram import (
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    KeyboardButton,
    ReplyKeyboardMarkup,
    ReplyKeyboardRemove,
    Update,
)
from telegram.ext import (
    Application,
    CallbackQueryHandler,
    CommandHandler,
    ContextTypes,
    MessageHandler,
    filters,
)
from telegram.request import HTTPXRequest
from dotenv import load_dotenv
load_dotenv()

# ‚îÄ‚îÄ‚îÄ CONFIG ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
API_BASE      = "https://www.autotechnik.store/api/v1"
API_V2        = "https://www.autotechnik.store/api/v2"
API_TOKEN     = "d579a8bdade5445c3683a0bb9526b657de79de53"
BOT_TOKEN     = os.getenv("TG_BOT_TOKEN")
CHECK_INTERVAL  = 120
REMIND_INTERVAL = 120  # —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ –Ω–æ–≤–æ–º —á–∞—Ç–µ ‚Äî –∫–∞–∂–¥—ã–µ 2 –º–∏–Ω—É—Ç—ã
DB_PATH         = "db.sqlite3"
HISTORY_LIMIT   = 50

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(levelname)-7s | %(message)s"
)

# ‚îÄ‚îÄ‚îÄ DATABASE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
conn = sqlite3.connect(DB_PATH, check_same_thread=False)
cur  = conn.cursor()
cur.executescript("""
CREATE TABLE IF NOT EXISTS users (
    telegram_id   INTEGER PRIMARY KEY,
    phone         TEXT,
    customer_id   INTEGER,
    manager_login TEXT,
    last_statuses TEXT
);
CREATE TABLE IF NOT EXISTS managers (
    manager_login TEXT PRIMARY KEY,
    telegram_id   INTEGER
);
""")
conn.commit()

# ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
client_chat  = {}               # client_tid ‚Üí customer_id
manager_chat = {}               # manager_tid ‚Üí customer_id
chat_manager = {}               # customer_id ‚Üí manager_login
unread       = defaultdict(set) # manager_tid ‚Üí set(customer_id)
history      = defaultdict(lambda: deque(maxlen=HISTORY_LIMIT))

# ‚îÄ‚îÄ‚îÄ HELPERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def normalize(ph: str | None) -> str:
    return ''.join(filter(str.isdigit, ph or ''))[-10:]

def clean(t: str | None) -> str:
    return (t or "").replace('\u00A0', ' ').strip()

def rub(val) -> str:
    try:
        return f"{float(val):,.2f}".replace(',', ' ').replace('.00','') + "¬†‚ÇΩ"
    except:
        return "‚Äî"

def manager_tid(login: str) -> int | None:
    cur.execute(
        "SELECT telegram_id FROM managers WHERE manager_login=?",
        (login,)
    )
    r = cur.fetchone()
    return r[0] if r else None

# ‚îÄ‚îÄ‚îÄ KEYBOARDS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
def kb_start():
    return ReplyKeyboardMarkup(
        [[KeyboardButton("üì≤ –û—Ç–ø—Ä–∞–≤–∏—Ç—å –Ω–æ–º–µ—Ä", request_contact=True)]],
        resize_keyboard=True
    )

def kb_client():
    return ReplyKeyboardMarkup(
        [
            ["üí¨ –ß–∞—Ç —Å –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º"],
            ["üìã –ú–æ–∏ –∞–∫—Ç–∏–≤–Ω—ã–µ –∑–∞–∫–∞–∑—ã"],
            ["üéÅ –ë–æ–Ω—É—Å–Ω–∞—è‚Äë–∫–∞—Ä—Ç–∞"],
            ["üìö –ö–∞—Ç–∞–ª–æ–≥–∏ —Ç–æ–≤–∞—Ä–æ–≤"]
        ],
        resize_keyboard=True
    )

def kb_manager():
    return ReplyKeyboardMarkup(
        [["üóÇ –ê–∫—Ç–∏–≤–Ω—ã–µ —á–∞—Ç—ã"], ["üë• –ú–æ–∏ –∫–ª–∏–µ–Ω—Ç—ã"]],
        resize_keyboard=True
    )

def ikb_mgr_chat():
    return InlineKeyboardMarkup([[
        InlineKeyboardButton("üõë –ó–∞–∫—Ä—ã—Ç—å —á–∞—Ç", callback_data="mgr_close"),
        InlineKeyboardButton("üìú –ò—Å—Ç–æ—Ä–∏—è",    callback_data="mgr_history"),
    ]])

def ikb_cli_chat():
    return InlineKeyboardMarkup([[
        InlineKeyboardButton("üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç", callback_data="cli_close"),
    ]])

def kb_client_chat():
    return ReplyKeyboardMarkup(
        [["üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç"]],
        resize_keyboard=True
    )

# ‚îÄ‚îÄ‚îÄ ORDER MESSAGE BUILDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
READY_PLAIN = re.compile(r"^–≥–æ—Ç–æ–≤–æ?\s+–∫\s+–≤—ã–¥–∞—á–µ$", re.I)
READY_DAY   = re.compile(r"^–≥–æ—Ç–æ–≤–æ?\s+–∫\s+–≤—ã–¥–∞—á–µ\s+(\d+)", re.I)
EXCLUDED    = {s.lower() for s in {
    "–í—ã–¥–∞–Ω–æ","–û—Ç–∫–∞–∑ –ø–æ—Å—Ç–∞–≤—â–∏–∫–∞","–û—Ç–∫–∞–∑ –∫–ª–∏–µ–Ω—Ç–∞",
    "–û—Ç–∫–∞–∑ –∫–ª–∏–µ–Ω—Ç–∞ –≤—ã—à–µ–ª —Å—Ä–æ–∫ —Ö—Ä–∞–Ω–µ–Ω–∏—è",
    "–≤–æ–∑–≤—Ä–∞—Ç –æ—Ç –ø–æ–∫—É–ø–∞—Ç–µ–ª—è","–í–æ–∑–≤—Ä–∞—Ç –ø–æ—Å—Ç–∞–≤—â–∏–∫—É",
    "–í–æ–∑–≤—Ä–∞—Ç –æ–¥–æ–±—Ä–µ–Ω","–í–æ–∑–≤—Ä–∞—Ç –æ—Ç–∫–ª–æ–Ω—ë–Ω"
}}

def order_message(oid, name, price, status, addr="", list_mode=False):
    st = clean(status)
    base = f"üì¶ *–ó–∞–∫–∞–∑ ‚Ññ{oid}*\n"
    addr_line = f"\nüè† –ü—É–Ω–∫—Ç –≤—ã–¥–∞—á–∏: {addr}" if addr else ""
    if READY_PLAIN.fullmatch(st):
        return base + f"{clean(name)} ‚Äî {rub(price)}{addr_line}\nüè¨ *–ì–æ—Ç–æ–≤ –∫ –≤—ã–¥–∞—á–µ!*"
    m = READY_DAY.match(st)
    if m:
        day = int(m.group(1))
        if day == 7:
            return base + f"{clean(name)} ‚Äî {rub(price)}{addr_line}\n‚ö†Ô∏è *–ü–æ—Å–ª–µ–¥–Ω–∏–π –¥–µ–Ω—å —Ö—Ä–∞–Ω–µ–Ω–∏—è!*"
        else:
            return base + f"{clean(name)} ‚Äî {rub(price)}{addr_line}\nüìÖ –û–∂–∏–¥–∞–π—Ç–µ, –≤–∞—à –∑–∞–∫–∞–∑ –≥–æ—Ç–æ–≤–∏—Ç—Å—è."
    if list_mode and st.lower() in EXCLUDED:
        return None
    return base + f"üõí {clean(name)} ‚Äî {rub(price)}\nüìå –°—Ç–∞—Ç—É—Å: {status}{addr_line}"

# ‚îÄ‚îÄ‚îÄ CATALOGS DATA ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
CATALOG_SECTIONS = {
    "61": [
        ("–ó–∞–ø—á–∞—Å—Ç–∏ –ø–æ —Ä–∞–∑–¥–µ–ª–∞–º",                "https://www.autotechnik.store/d_catalog3/61/"),
        ("–ó–∞–ø—á–∞—Å—Ç–∏ –¥–ª—è –≥—Ä—É–∑–æ–≤–æ–π —Ç–µ—Ö–Ω–∏–∫–∏",       "https://www.autotechnik.store/d_catalog3/124/"),
        ("–°–∏–ª–æ–≤—ã–µ –∞–≥—Ä–µ–≥–∞—Ç—ã",                  "https://www.autotechnik.store/d_catalog3/126/"),
        ("–ë–∞—á–∫–∏",                              "https://www.autotechnik.store/d_catalog3/61/bachci/"),
           ("–í—Ç—É–ª–∫–∏",                            "https://www.autotechnik.store/d_catalog3/61/vtulci/"),
            ("–í—Ç—É–ª–∫–∏ –º–µ—Ç–∞–ª–∏—á–µ—Å–∫–∏–µ",                "https://www.autotechnik.store/d_catalog3/61/vtulci-metalichescie/"),
            ("–í—ã—Ö–ª–æ–ø–Ω–∞—è —Å–∏—Å—Ç–µ–º–∞",             "https://www.autotechnik.store/d_catalog3/61/vihlopnaya-sistema/"),
            ("–ó–∞–≥–ª—É—à–∫–∏ / –î–µ—Ä–∂–∞—Ç–µ–ª–∏",         "https://www.autotechnik.store/d_catalog3/61/zaglushci/"),    
            ("–ó–∞–º–∫–∏",                          "https://www.autotechnik.store/d_catalog3/61/zamci/"),
            ("–ó–∞–ø—á–∞—Å—Ç–∏ –¥–≤–∏–≥–∞—Ç–µ–ª—è",             "https://www.autotechnik.store/d_catalog3/61/zapchasti-dvigatelya/"),
            ("–ó–µ—Ä–∫–∞–ª–∞",                             "https://www.autotechnik.store/d_catalog3/61/zercala/"),
            ("–ö–æ–∂—É—Ö–∏",                         "https://www.autotechnik.store/d_catalog3/61/corpusa--cojuhi/"),
            ("–ö—Ä–∞–Ω—ã",                       "https://www.autotechnik.store/d_catalog3/61/crani/"),
            ("–ö—Ä–µ—Å—Ç–æ–≤–∏–Ω—ã",                "https://www.autotechnik.store/d_catalog3/61/crestovini/"),
            ("–ö—Ä–æ–Ω—à—Ç–µ–π–Ω—ã",                  "https://www.autotechnik.store/d_catalog3/61/cronshteini/"),
    ],
    "autocatalog": [
        ("–ü–æ–¥–±–æ—Ä –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º", "https://www.autotechnik.store/autocatalog/"),
        ("–ü–æ–¥—à–∏–ø–Ω–∏–∫–∏",           "https://www.autotechnik.store/d_catalog3/94/"),
        ("–°–∞–ª—å–Ω–∏–∫–∏",             "https://www.autotechnik.store/d_catalog3/98/"),
        ("–†–µ–º–Ω–∏",                "https://www.autotechnik.store/d_catalog3/97/"),
    ],
    "110": [
        ("–ú–∞—Å–ª–∞",                    "https://www.autotechnik.store/d_catalog3/110/"),
        ("–ú–∞—Å–ª–∞ –º–æ—Ç–æ—Ä–Ω—ã–µ",           "https://www.autotechnik.store/d_catalog3/110/maslo-motornoe/"),
        ("–ú–∞—Å–ª–∞ —Ç—Ä–∞–Ω—Å–º–∏—Å—Å–∏–æ–Ω–Ω—ã–µ",    "https://www.autotechnik.store/d_catalog3/110/maslo-transmissionnoe-/"),
        # ... (–∏ —Ç.–¥.) ...
    ],
    "100": [
        ("–§–∏–ª—å—Ç—Ä–∞",                 "https://www.autotechnik.store/d_catalog3/100/"),
        ("–ú–∞—Å–ª—è–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä–∞",        "https://www.autotechnik.store/d_catalog3/100/maslyanie-filtra/"),
        # ...
    ],
    "103": [
        ("–ê–≤—Ç–æ—Ö–∏–º–∏—è",               "https://www.autotechnik.store/d_catalog3/103/"),
        ("AdBlue",                  "https://www.autotechnik.store/d_catalog3/103/adblue/"),
        # ...
    ],
    "42": [
        ("–õ–∞–∫–æ–∫—Ä–∞—Å–æ—á–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã", "https://www.autotechnik.store/d_catalog3/42/"),
        # ...
    ],
    "140": [
        ("–ê–±—Ä–∞–∑–∏–≤–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã",    "https://www.autotechnik.store/d_catalog3/140/"),
        # ...
    ],
    "142": [
        ("–ê–≤—Ç–æ–∞–∫—Å–µ—Å—Å—É–∞—Ä—ã",          "https://www.autotechnik.store/d_catalog3/142/"),
        # ...
    ],
    "31": [
        ("–ö—Ä–µ–ø—ë–∂–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã",      "https://www.autotechnik.store/d_catalog3/31/"),
        # ...
    ],
    "145": [
        ("–§–∞—Ä–∫–æ–ø—ã",                 "https://www.autotechnik.store/d_catalog3/145/"),
    ],
    "102": [
        ("–≠–ª–µ–∫—Ç—Ä–æ–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ",     "https://www.autotechnik.store/d_catalog3/102/"),
        # ...
    ],
}

# ‚îÄ‚îÄ‚îÄ SHOW TOP‚ÄëLEVEL CATALOGS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_catalogs(u: Update, _):
    buttons = [
        [InlineKeyboardButton("1. –ó–∞–ø—á–∞—Å—Ç–∏ –ø–æ —Ä–∞–∑–¥–µ–ª–∞–º", callback_data="cat:61")],
        [InlineKeyboardButton("2. –ü–æ–¥–±–æ—Ä –ø–æ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º", callback_data="cat:autocatalog")],
        [InlineKeyboardButton("3. –ú–∞—Å–ª–∞",                  callback_data="cat:110")],
        [InlineKeyboardButton("4. –§–∏–ª—å—Ç—Ä–∞",                callback_data="cat:100")],
        [InlineKeyboardButton("5. –ê–≤—Ç–æ—Ö–∏–º–∏—è",              callback_data="cat:103")],
        [InlineKeyboardButton("6. –õ–∞–∫–æ–∫—Ä–∞—Å–æ—á–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã",callback_data="cat:42")],
        [InlineKeyboardButton("7. –ê–±—Ä–∞–∑–∏–≤–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã",   callback_data="cat:140")],
        [InlineKeyboardButton("8. –ê–≤—Ç–æ–∞–∫—Å–µ—Å—Å—É–∞—Ä—ã",         callback_data="cat:142")],
        [InlineKeyboardButton("9. –ö—Ä–µ–ø—ë–∂–Ω—ã–µ —ç–ª–µ–º–µ–Ω—Ç—ã",     callback_data="cat:31")],
        [InlineKeyboardButton("10. –§–∞—Ä–∫–æ–ø—ã",               callback_data="cat:145")],
        [InlineKeyboardButton("11. –≠–ª–µ–∫—Ç—Ä–æ–æ–±–æ—Ä—É–¥–æ–≤–∞–Ω–∏–µ",   callback_data="cat:102")],
        [InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥ –≤ –º–µ–Ω—é",           callback_data="back_to_client")],
    ]
    await u.message.reply_text(
        "üìö –í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–¥–µ–ª –∫–∞—Ç–∞–ª–æ–≥–∞:",
        reply_markup=InlineKeyboardMarkup(buttons)
    )

# ‚îÄ‚îÄ‚îÄ SHOW SUBSECTIONS UPON CALLBACK ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_catalog_section(cbq: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await cbq.callback_query.answer()
    data = cbq.callback_query.data
    if data == "back_to_client":
        await cbq.callback_query.message.delete()
        return await cbq.callback_query.message.reply_text(
            "–í—ã –≤–µ—Ä–Ω—É–ª–∏—Å—å –≤ –≥–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é:", reply_markup=kb_client()
        )
    _, key = data.split(":", 1)
    items = CATALOG_SECTIONS.get(key, [])
    buttons = [[InlineKeyboardButton(text, url=url)] for text, url in items]
    buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è –ù–∞–∑–∞–¥", callback_data="cat:61")])
    await cbq.callback_query.message.edit_text(
        "üîπ –ü–æ–¥—Ä–∞–∑–¥–µ–ª—ã:",
        reply_markup=InlineKeyboardMarkup(buttons)
    )

# ‚îÄ‚îÄ‚îÄ /start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_start(u: Update, _):
    uid = u.effective_user.id
    cur.execute("SELECT 1 FROM managers WHERE telegram_id=?", (uid,))
    if cur.fetchone():
        await u.message.reply_text(
            "üëã –í—ã –≤–æ—à–ª–∏ –∫–∞–∫ *–º–µ–Ω–µ–¥–∂–µ—Ä*.",
            parse_mode="Markdown",
            reply_markup=kb_manager()
        )
    else:
        await u.message.reply_text(
            "üëã *–ù—É–∂–Ω–∞ –∞–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è!*\nüì± –û—Ç–ø—Ä–∞–≤—å—Ç–µ –Ω–æ–º–µ—Ä.",
            parse_mode="Markdown",
            reply_markup=kb_start()
        )

# ‚îÄ‚îÄ‚îÄ /manager or /reg1664 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_mgr_reg(u: Update, c: ContextTypes.DEFAULT_TYPE):
    if not c.args:
        return await u.message.reply_text(
            "–§–æ—Ä–º–∞—Ç: `/reg1664 <–ª–æ–≥–∏–Ω>`", parse_mode="Markdown"
        )
    login = c.args[0]
    cur.execute("INSERT OR REPLACE INTO managers VALUES(?,?)", (login, u.effective_user.id))
    conn.commit()
    await u.message.reply_text("‚úÖ –ó–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –∫–∞–∫ –º–µ–Ω–µ–¥–∂–µ—Ä!", reply_markup=kb_manager())

# ‚îÄ‚îÄ‚îÄ Contact ‚Üí client auth ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_contact(u: Update, _):
    phone = normalize(u.message.contact.phone_number)
    try:
        async with httpx.AsyncClient(timeout=20) as cl:
            r = await cl.get(f"{API_BASE}/customers/?token={API_TOKEN}")
        custs = r.json().get("result", [])
    except Exception as exc:
        return await u.message.reply_text(f"‚ùå API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–æ: {exc}")

    cust = next((x for x in custs if normalize(x.get("phone")) == phone), None)
    if not cust:
        return await u.message.reply_text("‚ùå –ù–æ–º–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω.")

    cid  = cust.get("id") or cust.get("customerID")
    mlog = cust.get("managerLogin") or ""
    cur.execute(
        "INSERT OR REPLACE INTO users (telegram_id,phone,customer_id,manager_login,last_statuses) VALUES(?,?,?,?,?)",
        (u.effective_user.id, phone, cid, mlog, json.dumps({}))
    )
    conn.commit()
    await u.message.reply_text("‚úÖ –ê–≤—Ç–æ—Ä–∏–∑–∞—Ü–∏—è —É—Å–ø–µ—à–Ω–∞!", reply_markup=kb_client())

# ‚îÄ‚îÄ‚îÄ Bonus card ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_card(u: Update, _):
    cur.execute("SELECT phone FROM users WHERE telegram_id=?", (u.effective_user.id,))
    row = cur.fetchone()
    if not row:
        return await u.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å.")
    code = normalize(row[0])
    url  = f"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data={quote_plus(code)}"
    await u.message.reply_photo(url, caption=f"üéÅ –í–∞—à–∞ –±–æ–Ω—É—Å–Ω–∞—è‚Äë–∫–∞—Ä—Ç–∞\n`{code}`", parse_mode="Markdown")

# ‚îÄ‚îÄ‚îÄ My orders ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_my_orders(u: Update, _):
    cur.execute("SELECT customer_id FROM users WHERE telegram_id=?", (u.effective_user.id,))
    r = cur.fetchone()
    if not r:
        return await u.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å.")
    cid = r[0]
    try:
        async with httpx.AsyncClient(timeout=25) as cl:
            r = await cl.get(f"{API_BASE}/customers/{cid}/orders/?token={API_TOKEN}&withPositions=1")
        r.raise_for_status()
    except Exception as exc:
        return await u.message.reply_text(f"‚ùå API: {exc}")
    sent = False
    for o in r.json().get("result", []):
        oid  = o.get("orderNumber") or o.get("id")
        addr = o.get("deliveryOrderAddress") or ""
        for p in o.get("positions", []):
            txt = order_message(oid, p.get("description"), p.get("price") or p.get("sum"), p.get("statusName"), addr=addr, list_mode=True)
            if txt:
                sent = True
                await u.message.reply_text(txt, parse_mode="Markdown")
    if not sent:
        await u.message.reply_text("üòä –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–∫–∞–∑–æ–≤.")

# ‚îÄ‚îÄ‚îÄ Chat request ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_chat_request(u: Update, _):
    cur.execute("SELECT customer_id,manager_login,phone FROM users WHERE telegram_id=?", (u.effective_user.id,))
    r = cur.fetchone()
    if not r:
        return await u.message.reply_text("–°–Ω–∞—á–∞–ª–∞ –∞–≤—Ç–æ—Ä–∏–∑—É–π—Ç–µ—Å—å.")
    cid, mlog, phone = r
    client_chat[u.effective_user.id] = cid
    chat_manager[cid]         = mlog
    mgr = manager_tid(mlog)
    if mgr:
        unread[mgr].add(cid)
        await app.bot.send_message(mgr, f"üîî –ù–æ–≤—ã–π —á–∞—Ç –æ—Ç {u.effective_user.full_name} ({phone})")
    await u.message.reply_text(
        "‚úÖ –ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–ª—É—á–∏–ª —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∏ –æ—Ç–≤–µ—Ç–∏—Ç –≤–∞–º –≤ –±–ª–∏–∂–∞–π—à–µ–µ –≤—Ä–µ–º—è.\n"
        "–ß–∞—Ç –Ω–∞—á–Ω—ë—Ç—Å—è –ø–æ—Å–ª–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –º–µ–Ω–µ–¥–∂–µ—Ä–∞\n"
        "‚è∞ –ß–∞—Å—ã —Ä–∞–±–æ—Ç—ã: –ü–Ω‚Äì–°–± 10:00‚Äì20:00, –í—Å ‚Äî –≤—ã—Ö–æ–¥–Ω–æ–π",
        reply_markup=ReplyKeyboardRemove()
    )
    await u.message.reply_text("–ï—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ —á—Ç–æ-—Ç–æ –µ—â—ë ‚Äì –ø–æ–ª—å–∑—É–π—Ç–µ—Å—å –º–µ–Ω—é –Ω–∏–∂–µ.", reply_markup=kb_client())

# ‚îÄ‚îÄ‚îÄ MANAGER LISTS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def _send_mgr_list(u: Update, *, active=False):
    uid = u.effective_user.id
    if active:
        title = "üóÇ *–ê–∫—Ç–∏–≤–Ω—ã–µ —á–∞—Ç—ã:*"
        opened  = [cid for mgr_tid, cid in manager_chat.items() if mgr_tid == uid]
        pending = [cid for cid in unread[uid] if cid not in opened]
        cids    = opened + pending
        if not cids:
            return await u.message.reply_text("–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç.")
        q = ",".join("?" for _ in cids)
        cur.execute(f"SELECT customer_id,telegram_id,phone FROM users WHERE customer_id IN ({q})", cids)
        rows = cur.fetchall()
    else:
        title = "üë• *–ú–æ–∏ –∫–ª–∏–µ–Ω—Ç—ã:*"
        cur.execute("SELECT manager_login FROM managers WHERE telegram_id=?", (uid,))
        r = cur.fetchone()
        if not r:
            return
        mlog = r[0]
        cur.execute("SELECT customer_id,telegram_id,phone FROM users WHERE manager_login=?", (mlog,))
        rows = cur.fetchall()
    buttons = []
    for cid, tid, phone in rows:
        try:
            name = (await u.get_bot().get_chat(tid)).full_name
        except:
            name = f"cid {cid}"
        label = f"{name} ({phone})"
        if active and cid in unread[uid]:
            label = "üî¥ " + label
        buttons.append([InlineKeyboardButton(label, callback_data=f"open:{cid}")])
    await u.message.reply_text(title, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(buttons))

async def h_btn_active(u: Update, _): await _send_mgr_list(u, active=True)
async def h_btn_clients(u: Update, _): await _send_mgr_list(u, active=False)

# ‚îÄ‚îÄ‚îÄ CALLBACKS (open/close/history) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_cb(upd: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cb = upd.callback_query
    await cb.answer()
    data, uid = cb.data, cb.from_user.id
    if data.startswith("open:"):
        cid = int(data.split(":", 1)[1])
        manager_chat[uid] = cid
        unread[uid].discard(cid)
        await ctx.bot.send_message(uid, "‚úÖ –ß–∞—Ç –æ—Ç–∫—Ä—ã—Ç.", reply_markup=ikb_mgr_chat())
        cur.execute("SELECT telegram_id FROM users WHERE customer_id=?", (cid,))
        r = cur.fetchone()
        if r:
            await ctx.bot.send_message(r[0], "üí¨ *–ú–µ–Ω–µ–¥–∂–µ—Ä –ø–æ–¥–∫–ª—é—á–∏–ª—Å—è.*", parse_mode="Markdown", reply_markup=kb_client_chat())
    elif data == "mgr_close":
        await _close_common(uid, ctx, from_manager=True)
    elif data == "mgr_history":
        cid  = manager_chat.get(uid)
        msgs = history.get(cid, [])
        text = "\n".join(f"*{who}:* {m}" for who, m in msgs) or "–ò—Å—Ç–æ—Ä–∏—è –ø—É—Å—Ç–∞."
        await cb.edit_message_text(text, parse_mode="Markdown", reply_markup=ikb_mgr_chat())
    elif data == "cli_close":
        await _close_common(uid, ctx, from_manager=False)

async def _close_common(uid, ctx, *, from_manager):
    if from_manager:
        cid = manager_chat.pop(uid, None)
        if cid:
            chat_manager.pop(cid, None)
            unread[uid].discard(cid)
            cur.execute("SELECT telegram_id FROM users WHERE customer_id=?", (cid,))
            r = cur.fetchone()
            if r:
                client_chat.pop(r[0], None)
                await ctx.bot.send_message(r[0], "üõë –ß–∞—Ç –∑–∞–∫—Ä—ã—Ç –º–µ–Ω–µ–¥–∂–µ—Ä–æ–º.", reply_markup=kb_client())
        await ctx.bot.send_message(uid, "üõë –ß–∞—Ç –∑–∞–∫—Ä—ã—Ç.", reply_markup=kb_manager())
    else:
        cid = client_chat.pop(uid, None)
        if cid:
            mlog = chat_manager.pop(cid, None)
            mgr  = manager_tid(mlog) if mlog else None
            if mgr:
                manager_chat.pop(mgr, None)
                unread[mgr].discard(cid)
                await ctx.bot.send_message(mgr, "üõë –ö–ª–∏–µ–Ω—Ç –∑–∞–≤–µ—Ä—à–∏–ª —á–∞—Ç.", reply_markup=kb_manager())
        await ctx.bot.send_message(uid, "üõë –ß–∞—Ç –∑–∞–≤–µ—Ä—à—ë–Ω.", reply_markup=kb_client())

async def h_cli_close(u: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await _close_common(u.effective_user.id, ctx, from_manager=False)

# ‚îÄ‚îÄ‚îÄ TEXT HANDLERS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def h_text_manager(u: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cid = manager_chat.get(u.effective_user.id)
    if not cid:
        return
    cur.execute("SELECT telegram_id FROM users WHERE customer_id=?", (cid,))
    r = cur.fetchone()
    if not r:
        return
    tgt = r[0]
    txt = u.message.text
    history[cid].append(("–ú–µ–Ω–µ–¥–∂–µ—Ä", txt))
    await ctx.bot.send_message(tgt, f"üë§ –ú–µ–Ω–µ–¥–∂–µ—Ä: {txt}")

async def h_text_client(u: Update, ctx: ContextTypes.DEFAULT_TYPE):
    cid = client_chat.get(u.effective_user.id)
    if not cid:
        return
    mlog = chat_manager.get(cid)
    mgr  = manager_tid(mlog) if mlog else None
    txt  = u.message.text
    history[cid].append((u.effective_user.full_name, txt))
    if mgr and manager_chat.get(mgr) == cid:
        await ctx.bot.send_message(mgr, f"üë§ {u.effective_user.full_name}: {txt}")
    else:
        if mgr:
            unread[mgr].add(cid)

# ‚îÄ‚îÄ‚îÄ BACKGROUND TASKS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def remind_unread():
    for mgr_tid, cids in unread.items():
        for cid in list(cids):
            cur.execute("SELECT phone FROM users WHERE customer_id=?", (cid,))
            row = cur.fetchone()
            phone = row[0] if row else "‚Äî"
            text = f"üîî –ù–æ–≤—ã–π —á–∞—Ç –æ—Ç {phone}"
            kb = InlineKeyboardMarkup([[
                InlineKeyboardButton("‚ñ∂ –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ —á–∞—Ç—É", callback_data=f"open:{cid}")
            ]])
            try:
                await app.bot.send_message(mgr_tid, text, reply_markup=kb)
            except:
                pass

def stable_ref(p):
    return (
        p.get("reference")
        or p.get("ref")
        or p.get("positionID")
        or p.get("id")
        or f"{p.get('article')}_{p.get('brand')}"
    )

async def check_once():
    cur.execute("SELECT telegram_id,customer_id,last_statuses FROM users")
    for tid, cid, last_json in cur.fetchall():
        try:
            async with httpx.AsyncClient(timeout=25) as cl:
                r = await cl.get(f"{API_BASE}/customers/{cid}/orders/?token={API_TOKEN}&withPositions=1")
            r.raise_for_status()
            orders = r.json().get("result", [])
        except:
            continue
        try:
            old = json.loads(last_json) if last_json else {}
        except:
            old = {}
        first_run = len(old) == 0
        now = {}
        to_send = []
        for o in orders:
            oid  = o.get("orderNumber") or o.get("id")
            addr = o.get("deliveryOrderAddress") or ""
            for p in o.get("positions", []):
                key  = f"{oid}__{stable_ref(p)}"
                stat = clean(p.get("statusName"))
                now[key] = stat
                if not first_run and old.get(key) != stat:
                    msg = order_message(oid, p.get("description"), p.get("price") or p.get("sum"), stat, addr=addr)
                    if msg:
                        to_send.append(msg)
        for m in to_send:
            try:
                await app.bot.send_message(tid, m, parse_mode="Markdown")
            except:
                pass
        cur.execute("UPDATE users SET last_statuses = ? WHERE telegram_id = ?", (json.dumps(now, ensure_ascii=False), tid))
    conn.commit()

# ‚îÄ‚îÄ‚îÄ MAIN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
async def main():
    if not BOT_TOKEN:
        raise RuntimeError("TG_BOT_TOKEN –Ω–µ –∑–∞–¥–∞–Ω!")
    req = HTTPXRequest(connect_timeout=10, read_timeout=30)
    global app
    app = Application.builder().token(BOT_TOKEN).request(req).build()

    # handlers
    app.add_handler(CommandHandler("start", h_start))
    app.add_handler(CommandHandler(["manager", "reg1664"], h_mgr_reg))
    app.add_handler(CommandHandler("stop", lambda u,c: _close_common(u.effective_user.id, c, from_manager=False)))
    app.add_handler(MessageHandler(filters.CONTACT, h_contact))
    app.add_handler(MessageHandler(filters.Regex("^üéÅ"), h_card))
    app.add_handler(MessageHandler(filters.Regex("^üìã"), h_my_orders))
    app.add_handler(MessageHandler(filters.Regex("^üí¨"), h_chat_request))
    app.add_handler(MessageHandler(filters.Regex("^üóÇ"), h_btn_active))
    app.add_handler(MessageHandler(filters.Regex("^üë•"), h_btn_clients))
    app.add_handler(MessageHandler(filters.Regex("^üìö"), h_catalogs))
    app.add_handler(CallbackQueryHandler(h_catalog_section, pattern=r"^cat:"))
    app.add_handler(CallbackQueryHandler(h_cb))

    # —Ç–µ–∫—Å—Ç–æ–≤—ã–µ —Ö—ç–Ω–¥–ª–µ—Ä—ã
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, h_text_manager), group=0)
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, h_text_client),  group=1)

    # –ª–æ–≤–∏–º ¬´üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç¬ª
    app.add_handler(MessageHandler(filters.Regex(r"^üõë –ó–∞–≤–µ—Ä—à–∏—Ç—å —á–∞—Ç$"), h_cli_close), group=2)

     # scheduler
    sch = AsyncIOScheduler()
    sch.add_job(check_once,    "interval", seconds=CHECK_INTERVAL)
    sch.add_job(remind_unread, "interval", seconds=REMIND_INTERVAL)
    sch.start()

    await app.initialize()
    await app.start()
    await app.updater.start_polling()
    logging.info("‚úÖ Bot started!")
    await asyncio.Event().wait()

if __name__ == "__main__":
    nest_asyncio.apply()
    asyncio.run(main())



